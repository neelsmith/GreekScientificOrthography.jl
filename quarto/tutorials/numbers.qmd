# Formatting numeric tokens
```{julia}
#| warning: false
#| echo: false
#| output: false
using GreekScientificOrthography, Orthography
```

Manuscripts of Greek scientific and mathematical texts use the "Milesian" system of numeric notation.

## Integers in the "Milesian" system of notation

### Values from 1-999

The Milesian system is essentially a place-value system.  The 27 values for ones (1-9), tens (10-90), and hundreds (100-900) are noted with specific alphabetic characters in normal alphabetic order, with the additions of `Ï›` for 6, `Ï™` for 90 and `Ï¡` for 900. 

::: {.callout-note}
Note that in `GreekScientificOrthography`, characters used to write the basic integer values *must be in lower-case*.
:::


::: {.column width="50%"}

| Ones | Tens | Hundreds |
| --- | --- | --- | 
| Î± | Î¹  | Ï |
| Î² | Îº | Ïƒ |
| Î³ | Î» | Ï„ |
| Î´ | Î¼ | Ï… |
| Îµ| Î½ | Ï† |
| Ï› | Î¾ | Ï‡ |
| Î¶| Î¿ | Ïˆ |
| Î·| Ï€ | Ï‰ |
| Î¸  | Ï™ | Ï¡ |

:::


Since most of the characters used to write integers in the Milesian system can also be alphabetic characters, integer tokens are flagged with a special marker, the numeric tick mark, `Í´` (Unicode x0374). The integer value `1` is written like this:

```{julia}
#| output: false
one = "Î±Í´" 
```


The sequence of digits is always smallest to largest from right to left. Note that their is no need for a zero character to represent the absence of a value is hundreds, tens or ones column, since the characters are distinct.



```{julia}
#| output: false
eleven = "Î¹Î±Í´"
one_hundred_one = "ÏÎ±Í´"
one_hundred_eleven = "ÏÎ¹Î±Í´"
```

All of these are valid strings in a `GreekSciOrthography`.

```{julia}
ortho = stemortho()
validstring(one, ortho) == validstring(eleven, ortho) == validstring(one_hundred_one, ortho) == validstring(one_hundred_eleven, ortho)
```


A comma separates thousands values from 1,000 - 9,000 (left of the comma) from hundreds, tens and ones. The thousands values reuse the same characters as the ones values.

```{julia}
one_thousand_one = "Î±,Î±Í´"
validstring(one_thousand_one, ortho)
```

All of these strings represent a single integer token (type `MilesianIntegerToken`).

```{julia}
tokenize(one, ortho)
```


```{julia}
tokenize(one_thousand_one, ortho)
```

## Integers from 999-19,999

The value for 10,000 is written with the upper-case mu, `Îœ` (for Î¼Ï…ÏÎ¹á½±Ï‚, "myriad").

```{julia}
myriad = "ÎœÍ´"
validstring(myriad, ortho)
```

Conventionally, the myriads value is written as a separate token separated by white space from the smaller columns. That means that a value like 10,001 will be parsed as two tokens. 

```{julia}
tenthousand_one = "ÎœÍ´ Î±Í´"
tokenize(tenthousand_one, ortho)
```

::: {.callout-note}
Greek manuscripts do not normally repeat the tick mark on the myriad marker; `GreekScientificOrthography` requires this to guarantee context-independent parsing of tokens.
:::


You can express whole numbers up to 19,999 in this way.

```{julia}
nineteen_999 = "ÎœÍ´ Î¸,Ï¡Ï™Î¸Í´"
validstring(nineteen_999, ortho)
```

```{julia}
tokenize(nineteen_999, ortho)
```


## Integers greater than 19,999

To write values larger than 19,999, Milesian notation begins by multiplying the myriad character. In manuscripts, the multiplier is normally written above the `Îœ`; in `GreekScientificOrthography`, we use the markdown convention for superscript that is supported by pandoc, among others, of bracketing the superscript value with carets. In this context, neither numeric character requires the numeric tick.

20,000, for example, is written as Îœ multiplied by Î², like this example:

```{julia}
twentyk = "Îœ^Î²^"
validstring(twentyk, ortho)
```

When you display the value in an environment that supports pandoc's markdown extension, the multiplier will display as a superscript.

```{julia}
using Markdown
Markdown.parse(twentyk)
```


Archimedes uses this notation as he derives limiting values for *pi* in  his treatise  *Measurement of a Circle*. The value 349,450, for example, is written with these two tokens:

```{julia}
threefortynine450 = "Îœ^Î»Î´^ ,Î¸Ï…Î½Í´"
Markdown.parse(threefortynine450)
```

```{julia}
tokenize(threefortynine450, ortho)
```



## Fractional values

`GreekScientificOrthography` includes characters for three fractional values that are often written in manuscripts with special symbols: `ğ…µ` for one half, `ğ…·` for two-thirds, and `ğ…¸` for three quarters.

Apart from these special cases, the only notation for fractional values available to Greek mathematicians was to use normal integer notation, but flagged with a special double-prime marker indicating that this is a *reciprocal* value.  

```{julia}
sixth = "Ï›â€³"
thirtysixth = "Î»Ï›â€³"
validstring(sixth, ortho) == validstring(thirtysixth, ortho)
```

Other fractional values would be written as sums of these.  The fraction 2/3 can, for example, appear as 1/2 + 1/6, written simply as a succession of individual fractional tokens. As with integer values, the sequence is least to greatest from right to left.

```{julia}
twothirds = "Î²â€³ Ï›â€³"
tokenize(twothirds, ortho)
```

Fractions can of course be mixed with integer numbers.

```{julia}
six_and_twothirds = "Ï›Í´ Î²â€³ Ï›â€³"
```

## Using integer values in hexadecimal units


::: {.callout-note title="TBA"}

An alternative to tedious sums of fractions:

- divide whole units into sixtieths, seconds (3600ths), thirds (216000ths)... each written with an integer value up to 59
- typically used in tables where columns determine meaning of integer
- but manually written columns make null values dangerous if they're left blank, so adds special character `ÎŸ` (Î¿á½Î´á½³Î½, "nothing") for 0.

:::